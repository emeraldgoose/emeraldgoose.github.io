I"+$<h2 id="databricks-vector-search">Databricks Vector Search</h2>
<p>Databricks에는 벡터 검색을 위한 벡터 검색 엔드포인트 및 인덱스를 생성하고 사용할 수 있습니다. Databricks의 Unity Catalog에 등록되었으며 ChangeDataFeed가 활성화된 테이블에 대해서만 인덱스를 생성할 수 있고 Sync를 통해 테이블 업데이트시 인덱스도 같이 업데이트가 가능합니다.</p>

<p>Semantic 검색을 지원하고 있지만 BM25와 같은 Lexical Search도 함께 지원하고 있다는 점도 강점이지만 잘 알려지지 않는 것 같습니다. 그래서 이 글에선 Vector search에 대해 정리해보려고 합니다.</p>

<h2 id="vector-search-endpoint">Vector Search Endpoint</h2>
<p>벡터 서치 엔드포인트는 인덱스를 관리할 수 있는 인스턴스 같은 개념입니다. 워크스페이스 왼쪽 항목에서 Compute에 Vector Search 탭이 있고 여기에 생성한 엔드포인트 목록이 보이게 되고 각 엔드포인트에는 생성한 인덱스 목록도 함께 보이게 됩니다.</p>

<h2 id="vector-search-index">Vector Search Index</h2>
<p>벡터 서치 인덱스는 임베딩 벡터가 포함된 인덱스를 말합니다. 기존 테이블에서 임베딩 대상이 되는 컬럼에 대한 임베딩 벡터를 생성해서 <code class="language-plaintext highlighter-rouge">__db_review_vector</code>라는 이름의 컬럼에 삽입됩니다. 인덱스도 Unity Catalog의 관리를 받게 되고 테이블 목록과 함께 나타납니다.</p>

<h3 id="databricks-vectorsearch">databricks-vectorsearch</h3>
<p>Databricks에선 워크스페이스 환경에서 벡터 서치를 이용할 수 있는 파이썬 기반의 라이브러리를 제공 중에 있습니다. 아래 명령어를 통해 설치하고 사용할 수 있습니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%pip install databricks-vectorsearch
</code></pre></div></div>

<p>사용법은 간단합니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">databricks.vector_search.client</span> <span class="kn">import</span> <span class="n">VectorSearchClient</span>

<span class="n">client</span> <span class="o">=</span> <span class="n">VectorSearchClient</span><span class="p">()</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">endpoint_name</span><span class="o">=</span><span class="s">"vector_search_endpoint"</span><span class="p">,</span> <span class="n">index_name</span><span class="o">=</span><span class="s">"{catalog}.{schema}.{index_name}"</span><span class="p">)</span>

<span class="n">results</span> <span class="o">=</span> <span class="n">index</span><span class="p">.</span><span class="n">similarity_search</span><span class="p">(</span>
    <span class="n">query_text</span><span class="o">=</span><span class="s">"Their Outback Oatmeal and Austin Almond Biscotti were dry and flavorless."</span><span class="p">,</span>
    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">"review"</span><span class="p">],</span>
    <span class="n">num_results</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="p">)</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Output
{
    'manifest': {'column_count': 2, 'columns': [{'name': 'review'}, {'name': 'score'}]},
    'result': {
        'row_count': 5,
        'data_array': [
            ["Bakehouse in Wynwood, Miami, has disappointed me. ... I expected more from a renowned cookie company.", 0.9040976460331299],
            ...
        ]
    }
}
</code></pre></div></div>
<p>similarity_search의 기본값은 ANN이기 때문에 <code class="language-plaintext highlighter-rouge">query_type</code>에 아무런 값을 주진 않았다면 Semantic Search가 자동으로 적용됩니다.</p>

<p>이름이 벡터 서치이기 때문에 Semantic Search만 지원하는 건가 싶지만 사실 그렇지는 않습니다. Lexical Search만 이용할 수도 있고 Semantic Search와 함께 사용하는 Hybrid Search도 지원하고 있습니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">databricks.vector_search.client</span> <span class="kn">import</span> <span class="n">VectorSearchClient</span>

<span class="n">client</span> <span class="o">=</span> <span class="n">VectorSearchClient</span><span class="p">()</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">endpoint_name</span><span class="o">=</span><span class="s">"vector_search_endpoint"</span><span class="p">,</span> <span class="n">index_name</span><span class="o">=</span><span class="s">"{catalog}.{schema}.{index_name}"</span><span class="p">)</span>

<span class="n">results</span> <span class="o">=</span> <span class="n">index</span><span class="p">.</span><span class="n">similarity_search</span><span class="p">(</span>
    <span class="n">query_text</span><span class="o">=</span><span class="s">"Their Outback Oatmeal and Austin Almond Biscotti were dry and flavorless."</span><span class="p">,</span>
    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">"review"</span><span class="p">],</span>
    <span class="n">num_results</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">query_type</span><span class="o">=</span><span class="s">"FULL_TEXT"</span><span class="p">,</span> <span class="c1"># bm25
</span><span class="p">)</span>

<span class="n">results</span> <span class="o">=</span> <span class="n">index</span><span class="p">.</span><span class="n">similarity_search</span><span class="p">(</span>
    <span class="n">query_text</span><span class="o">=</span><span class="s">"Their Outback Oatmeal and Austin Almond Biscotti were dry and flavorless."</span><span class="p">,</span>
    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">"review"</span><span class="p">],</span>
    <span class="n">num_results</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">query_type</span><span class="o">=</span><span class="s">"hybrid"</span><span class="p">,</span> <span class="c1"># hybrid
</span><span class="p">)</span>
</code></pre></div></div>
<p>단, Hybrid Search의 경우 RRF(Reciprocal Rank Fusion) 알고리즘으로 계산됩니다. 만약, CC(Convex Combination)를 적용하고 싶다면 <code class="language-plaintext highlighter-rouge">query_type</code>을 <code class="language-plaintext highlighter-rouge">FULL_TEXT</code>와 <code class="language-plaintext highlighter-rouge">ANN</code>으로 각각 검색하여 스코어 정규화를 거쳐 계산하는 함수를 작성해야 합니다.</p>

<p>추가적으로, debug_level=1을 넣어주면 debug_info라는 필드가 추가되면서 처리 시간이 나타는데 <code class="language-plaintext highlighter-rouge">query_type</code>에 따라 달라지는 것을 볼 수 있습니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># query_type=ann
</span><span class="s">'debug_info'</span><span class="p">:</span> <span class="p">{</span><span class="s">'response_time'</span><span class="p">:</span> <span class="mf">321.0</span><span class="p">,</span> <span class="s">'ann_time'</span><span class="p">:</span> <span class="mf">98.0</span><span class="p">,</span> <span class="s">'embedding_gen_time'</span><span class="p">:</span> <span class="mf">215.0</span><span class="p">}</span>

<span class="c1"># query_type=FULL_TEXT
</span><span class="s">'debug_info'</span><span class="p">:</span> <span class="p">{</span><span class="s">'response_time'</span><span class="p">:</span> <span class="mf">22.0</span><span class="p">,</span> <span class="s">'ann_time'</span><span class="p">:</span> <span class="mf">16.0</span><span class="p">}</span>

<span class="c1"># query_type=hybrid
</span><span class="s">'debug_info'</span><span class="p">:</span> <span class="p">{</span><span class="s">'response_time'</span><span class="p">:</span> <span class="mf">364.0</span><span class="p">,</span> <span class="s">'ann_time'</span><span class="p">:</span> <span class="mf">96.0</span><span class="p">,</span> <span class="s">'embedding_gen_time'</span><span class="p">:</span> <span class="mf">260.0</span><span class="p">}</span>
</code></pre></div></div>

<p>이 debug_info를 보면 lexical search에서 ann_time이라는 필드가 나오는 것으로 봐서 bm25 알고리즘이 아닐 수 있냐는 의문이 들 수도 있는데 제 생각으로는 sparse embedding으로 저장한 뒤</p>
:ET