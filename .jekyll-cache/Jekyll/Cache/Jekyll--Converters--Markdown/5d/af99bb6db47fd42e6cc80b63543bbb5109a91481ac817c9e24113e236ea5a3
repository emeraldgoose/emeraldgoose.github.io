I"
<h2 id="reference">Reference</h2>
<p><a href="https://ratsgo.github.io/nlpbook/docs/preprocess/bpe/">https://ratsgo.github.io/nlpbook/docs/preprocess/bpe/</a></p>

<h2 id="byte-pair-encoding">Byte Pair Encoding</h2>
<blockquote>
  <p>BPE 알고리즘에 대한 설명은 위에 링크한 곳에 잘 설명되어 있습니다. 여기서는 참고한 곳의 내용을 바탕으로 구현방법에 대해 설명하겠습니다.</p>
</blockquote>

<h3 id="get-vocabulary">get vocabulary</h3>
<p>토크나이징을 위해 문서내에 등장한 단어의 등장횟수가 기록된 <code class="language-plaintext highlighter-rouge">dictionary</code>를 사용하여 단어 집합인 <code class="language-plaintext highlighter-rouge">vocabulary</code>를 만들어야 합니다.</p>

<script src="https://gist.github.com/emeraldgoose/26465d827bd585a22796ba0461b10014.js"></script>

<p>위 코드는 <code class="language-plaintext highlighter-rouge">dictionary</code>의 단어들을 구성하는 글자들만을 추출하여 <code class="language-plaintext highlighter-rouge">vocabulary</code>에 저장한 코드입니다. 알고리즘 내에서 <code class="language-plaintext highlighter-rouge">vocabulary</code>를 사용하고 다시 업데이트를 반복할 것입니다.</p>

<p>모든 단어에 대한 bigram 쌍을 <code class="language-plaintext highlighter-rouge">pairs</code>라는 딕셔너리에 저장하면서 횟수를 저장합니다.</p>

<script src="https://gist.github.com/emeraldgoose/c2726eaffd762b1498a689bf751745a7.js"></script>

<p><code class="language-plaintext highlighter-rouge">pairs</code>에서 가장 많이 등장한 순대로 정렬 후 가장 많은 단어를 vocabulary에 저장합니다.</p>

<script src="https://gist.github.com/emeraldgoose/79fc8c2d59f6647c4b8a2ef289c429ae.js"></script>

<p>여기까지의 과정을 반복합니다.</p>

<script src="https://gist.github.com/emeraldgoose/98cf430f0d69833753dc969b5b1560fd.js"></script>

<h3 id="tokenizing">tokenizing</h3>
<p>토크나이징을 하려면 vocabulary가 필요합니다. vocabulary가 list 자료구조를 이용하는 이유는 등장 횟수가 많은 단어를 순서대로 추가하기 때문입니다.</p>

<script src="https://gist.github.com/emeraldgoose/200425885cfbf199eb560967cda36768.js"></script>

<p><code class="language-plaintext highlighter-rouge">&lt;unk&gt;</code> 토큰은 토크나이저가 vocabulary에 없는 단어를 대체할 때 사용합니다. 이런 문제를 OOV(Out of Vocabulary)라 하는데 여기서는 사전의 크기가 크지 않아 발생합니다. 보통 vocabulary를 구축할 때는 많은 corpus로부터 생성하므로 발생빈도가 vocabulary 크기에 따라 달라집니다.</p>

:ET